# 概述

动态规划（Dynamic Programming, 简称 DP）是一种**通过拆解问题、利用子问题的最优解构建出全局最优解**的算法设计思想。它特别适用于解决具有**重叠子问题**和**最优子结构**特性的优化问题。

动态规划的本质是**通过记住过去来优化未来**。它通过存储中间结果避免重复计算，从而大幅提高效率。

## 核心思想

1. **重叠子问题**：
   - 问题可以分解为许多重复出现的子问题。
   - 通过保存子问题的解（通常使用数组或表），避免重复计算，提高效率。
   - 比如斐波那契数列：`F(n) = F(n-1) + F(n-2)`，计算 `F(5)` 时，`F(3)` 会被多次求解。
2. **最优子结构**：
   - 问题的最优解可以通过子问题的最优解构造出来。
   - 比如最短路径问题，当前点到目标点的最短路径可以分解为某个中间点的最短路径加上剩余路径的最短路径。
3. **状态转移方程**：
   - 明确如何从子问题的解递推到更大的问题。
   - 它是动态规划问题的核心，一般以递归公式的形式表示问题的逻辑关系。

## 动态规划的实现步骤

动态规划一般分为以下几个步骤：

1. **定义状态（状态表示）**：
   - 找到问题的「阶段」和「状态」，明确如何表示一个子问题。
   - 状态通常用数组 `dp[i]` 表示，例如 `dp[i]` 表示前 `i` 项的最优解。
2. **状态转移方程**：
   - 找出状态之间的递推关系，即如何从前一个状态转移到当前状态。
   - 比如：
     - 斐波那契数列：`dp[i] = dp[i-1] + dp[i-2]`。
     - 背包问题：`dp[i][w] = max(dp[i-1][w], dp[i-1][w-wi] + vi)`。
3. **初始化**：
   - 为递归或迭代提供起始条件，通常是边界条件。
   - 比如，斐波那契数列 `dp[0] = 0, dp[1] = 1`。
4. **递推计算**：
   - 从初始状态出发，根据状态转移方程，逐步推导出问题的最终解。
5. **返回结果**：
   - 最后，根据递推的结果返回问题的解。



## 和贪心算法的比较

| **比较点**   | **动态规划**                     | **贪心算法**                                       |
| ------------ | -------------------------------- | -------------------------------------------------- |
| **决策方式** | 通过枚举所有可能，选择最优解     | 局部最优，试图一步步累积全局最优                   |
| **适用场景** | 具有重叠子问题和最优子结构的问题 | 无需回溯、选择当前最优即为全局最优的问题           |
| **复杂性**   | 通常较高（`O(n^2)` 或 `O(nm)`）  | 通常较低（`O(n)` 或更少）                          |
| **结果**     | 一定能得到最优解                 | 不一定得到最优解，依赖于问题是否满足贪心策略的条件 |



# [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/?envType=study-plan-v2&envId=top-100-liked)

最基础的动态规划

有两种方法到达第n级台阶，从n-1级爬1级，从n-2级爬两级，因此可以得到如下结论：

* f(n) = f(n - 1) + f(n - 2)

使用数组缓存已经计算过的结果

```ts
function climbStairs(n: number): number {
    // res[n - 1]表示达到第n阶的方法数量
    const res: number[] = Array(n).fill(0);
    res[0] = 1;
    res[1] = 2;
    for (let i = 2; i < n; i++) {
        res[i] = res[i - 1] + res[i - 2];
    }
    return res[n - 1];
};
```





# [118. 杨辉三角](https://leetcode.cn/problems/pascals-triangle/?envType=study-plan-v2&envId=top-100-liked)

![img](https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif)

把杨辉三角左对齐可以方便理解：

```
[1]
[1,1]
[1,2,1]
[1,3,3,1]
[1,4,6,4,1]
```

这样可以得知两个规律

* 每行第一个元素为1
* 每行剩余值 = 正上方 + 左上方的值，不存在就视为0

```ts
function generate(numRows: number): number[][] {
    const res = new Array(numRows);
    for (let i = 0; i < numRows; i++) {
        res[i] = new Array(i + 1);
        // 每行第一个值都是1
        res[i][0] = 1;
        // 每行剩余值，都等于左上方 + 正上方的值
        for (let j = 1; j <= i; j++) {
            res[i][j] = (res[i - 1][j - 1] || 0) + (res[i - 1][j] || 0);
        }
    }
    return res;
};
```

